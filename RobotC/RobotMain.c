#pragma config(Sensor, dgtl1,  Shooter_Sp,     sensorRotation)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           intakeMotor,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           naMotor,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           elevatorMotor, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           shooterMotor,  tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//
// OCCRA Ball Shooting Robot:						Last Update: 10/25/2016
//
// 

// Function prototypes go here...
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
task MotorSlewRateTask( );
task ShooterSpControl();

// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define INTAKE_SCALE	0.500					// Percent speed to run motor.
#define ELEVATOR_SCALE	0.500

#define MAX_SP			127						// Max Motor Speed
#define FWD				1						// Forward
#define REV				(-1)					// Reverse
#define STOP			0                   	// Motor Stop Speed
#define SHOOTER_SP		( 0.4384 * MAX_SP )		// Scaled Shooter Output Speed.


// Slew Rate Control Values
#define MOTOR_NUM               6		// First six motors get slew rate control.
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 3		// Default will cause 375mS from full fwd to rev
#define MOTOR_TASK_DELAY        25      // Task Rate = 1/frequency in mS (about 66Hz)

#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H)		max( min( T, H ), L)

// Globals
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

int mot[ MOTOR_NUM ];			// Array to hold requested speed for the motors.

int Shooter_Speed = 0;			// Local Copy of Shooter Speed.
int Shooter_Target = 0;			// Target speed for shooter motor.
int Shooter_PWM = 0;			// Default PWM Output for Shooter.

// ============================================================================
task main () {

	int joy_x, joy_y;

	startTask( MotorSlewRateTask );		// Start motor slew rate control task.
	startTask( ShooterSpControl );		// Task handles controlling the shooter motor.

	while ( true ) {

		// Drive Code..........................................................
		joy_x = vexRT[Ch1];		// Grab a copy of the values from the system vars.
		joy_y = vexRT[Ch3];

		// Compute movement based on a foward / reverse knob and a steering knob.
		mot[ leftMotor ]  = LimitVal( -127, (joy_x - joy_y)/2, 127 );
		mot[ rightMotor ] = LimitVal( -127, (joy_x + joy_y)/2, 127 );


		// Intake code.........................................................
		if ( vexRT[ Btn5UXmtr2 ] ) { //If the upper left trigger is pressed
			motor[ intakeMotor ] = INTAKE_SCALE * 127; //set intake motor forward
		}
		else if ( vexRT[Btn5DXmtr2 ] ) {	//If the bottom left trigger is pressed
			mot[ intakeMotor ] = INTAKE_SCALE * -127; //set intake motor reverse
		}
		else {
			mot[ intakeMotor ] = STOP;
		}

		// Elevator............................................................
		if ( vexRT[ Btn6UXmtr2 ] ) {
			mot[ elevatorMotor ] = ELEVATOR_SCALE * 127;
			mot[ intakeMotor ] = INTAKE_SCALE * 127;
		}
		else if ( vexRT[ Btn6DXmtr2 ] ) {
			mot[ elevatorMotor ] = ELEVATOR_SCALE * -127;
			mot[ intakeMotor ] = INTAKE_SCALE * -127;
		}
		else {
			mot[elevatorMotor] = 0;
		}

		// Shooter.............................................................
		// Note, the "ShooterSpControl" task takes care of setting the actual
		// motor speed.  Setting "Shooter_Target" just sets a desired speed.
		if ( vexRT[ Btn8DXmtr2 ] )			Shooter_Target = 20;
		else if ( vexRT[ Btn7DXmtr2 ] )		Shooter_Target = -10;
		else								Shooter_Target = 0;


		// Give other task(s) time to run too.
		wait1Msec( 20 );
	}
}


// ============================================================================
// Control the shooter speed using a feedback sensor.  The sensor counts two
// counts per revolution. Delta counts are calculated every 100ms.
// ============================================================================
task ShooterSpControl( ) {
	int Sp_Old = SensorValue( Shooter_Sp );
	int offset=0;

	while ( 1 ) {
		// Calculate delta speed every 100ms.
		Shooter_Speed = SensorValue( Shooter_Sp ) - Sp_Old;
		Sp_Old = SensorValue( Shooter_Sp );
		wait1Msec( 100 );

		if ( Shooter_Target == STOP ) {
			// Drive Shooter_PWM to zero five steps at a time.
			if ( Shooter_PWM > 5 )			Shooter_PWM -= 5;
			else if ( Shooter_PWM < -5 )	Shooter_PWM += 5;
			else							Shooter_PWM	= STOP;

			// By not reseting offset to zero the next time a target is
			// set the offset should be approximatly correct.
		}
		else {
			// Adjust motor offset if not on target.
			if ( Shooter_Speed < Shooter_Target )		offset += 1;
			else if ( Shooter_Speed > Shooter_Target )	offset -= 1;

			Shooter_PWM = LimitVal( -127, (SHOOTER_SP + offset), 127);

			// Keep offset from winding up.
			//offset = Shooter_PWM - SHOOTER_SP;
		}

		motor[ shooterMotor ] = Shooter_PWM;
	}
}


// ============================================================================
//  Task  - Compares the requested speed of each motor to the current speed
//          and increments or decrements to reduce the difference as nexessary
// ============================================================================
task MotorSlewRateTask( ) {

	int motorIndex;
	int motorTmp;

	// Array to hold "slew rate" for the motors, the maximum change every time the task
	// runs checking current mootor speed.
	int motorSlew[ MOTOR_NUM ];


	// Initialize stuff
	for ( motorIndex=0 ; motorIndex < MOTOR_NUM ; motorIndex++ ) {
		mot[ motorIndex ] = 0;
		motorSlew[ motorIndex ] = MOTOR_DEFAULT_SLEW_RATE;
	}

	while ( 1 ) {

		// For each motor...
		for ( motorIndex=0 ; motorIndex < MOTOR_NUM ; motorIndex++ ) {

			// So we don't keep accessing the internal storage
			motorTmp = motor[ motorIndex ];

			// Do we need to change the motor value?
			if ( motorTmp != mot[ motorIndex ] ) {

				// Increasing motor value
				if ( mot[ motorIndex ] > motorTmp ) {
					motorTmp += motorSlew[ motorIndex ];
					// limit
					if ( motorTmp > mot[ motorIndex ] )
						motorTmp = mot[ motorIndex ];
				}

				// Decreasing motor value
				if ( mot[ motorIndex ] < motorTmp ) {
					motorTmp -= motorSlew[motorIndex ];
					// limit
					if ( motorTmp < mot[ motorIndex ] )
						motorTmp = mot[ motorIndex ];
				}

				// Finally, set the actual motor output.
				motor[motorIndex] = LimitVal( -127, motorTmp, 127 );
			}
		}

		// Let other tasks run too.  Plus, this delay also affects the slew
		// rate of the motors.  Set this wisely. 
		wait1Msec( MOTOR_TASK_DELAY );
	}
}


