#pragma config(Motor,  port2,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           intakeMotor,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,            ,             tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           elevatorMotor, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           shooterMotor,  tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                 - Team 4384 OCCRA 2016 main robot code -                                 *|
|*                                      ROBOTC on VEX 2.0 Cortex                                      *|
|*																																																	  *|
\*----------------------------------------------------------------------------------------------------*/

//++++++++++++++++++++++++++++++++++++++++++++++| MAIN |++++++++++++++++++++++++++++++++++++++++++++++++

// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define LEFT_DRIVE_SCALE				1.0000		//1 initially
#define RIGHT_DRIVE_SCALE				1.0000		//1 initially
#define INTAKE_SCALE						0.5000		//.5 initially
#define ELEVATOR_SCALE					0.5000		//.5 initially
#define SHOOTER_SCALE 					0.4384		//.4384 initially
#define REV_SHOOTER_SCALE				0.1500		//.15 initially

// Function prototypes
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
float determineSpeed(float x);
int min(int x, int y);
int max(int x, int y);

// ============================================================================

//Main Robot Code
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
task main ()
{

  while(true)
  {
 	//Drive Code
  	float lval = determineSpeed(vexRT[Ch3]) + determineSpeed(vexRT[Ch1]); //Since the left joystick (Ch3) is used for forward motion and the right joystick (Ch1) is used for turning, combines the two
  	float processedLval = max(min(lval, 127), -127); //Restricts rval to the range [-127, 127]

  	float rval = determineSpeed(vexRT[Ch3]) - determineSpeed(vexRT[Ch1]);//Since the left joystick (Ch3) is used for forward motion and the right joystick (Ch1) is used for turning, combines the two
		float processedRval = max(min(rval, 127), -127); //Restricts lval to the range [-127, 127]

		motor[rightMotor] = processedRval * RIGHT_DRIVE_SCALE;
    motor[leftMotor] =  processedLval * LEFT_DRIVE_SCALE;


		//intake code
		if (vexRT[Btn5UXmtr2]){ //If the upper left trigger is pressed
			motor[intakeMotor] = INTAKE_SCALE * 127; //set intake motor forward
		}
		else if (vexRT[Btn5DXmtr2]){ //If the bottom left trigger is pressed
			motor[intakeMotor] = INTAKE_SCALE * -127; //set intake motor reverse
		}
		else{
			motor[intakeMotor] = 0; //Stops intake motor if no buttons are pressed
		}

		//elevator
		if (vexRT[Btn6UXmtr2]){
			motor[elevatorMotor] = ELEVATOR_SCALE * 127;
			motor[intakeMotor] = INTAKE_SCALE * 127;
		}
		else if (vexRT[Btn6DXmtr2]){
			motor[elevatorMotor] = ELEVATOR_SCALE * -127;
			motor[intakeMotor] = INTAKE_SCALE * -127;
		}
		else{
			motor[elevatorMotor] = 0;
		}

		//Shooter
		if(vexRT[Btn8DXmtr2]){
			motor[shooterMotor] = SHOOTER_SCALE * 127;
		}
		else{
			motor[shooterMotor] = 0;
		}

		if(vexRT[Btn7DXmtr2]){
			motor[shooterMotor] = REV_SHOOTER_SCALE * -127;
		}

	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//++++++++++++++++++++++++++++++++++++++| FUNCTION DEFINITIONS |++++++++++++++++++++++++++++++++++++++
float determineSpeed(float x){
	float y = 0;
	float c = 1.0/11.27; //11.27 is the sqrt of 127
	if(x>0){ //If x is positive
  	y = c *(x * sqrt(x)); //Raises x to the 1.5 power
	}
	else{
		y = -1.0 * c *((-1.0 * x) * sqrt(-1.0 * x)); //Raises x to the 1.5 power, but negates final answer.
	}
	return y;
}

//Finds minimum of two values
int min(int x, int y) {
	if (x < y){ //If x is the smaller number, return x
		return x;
	}
	else { //Otherwise return y. This is so that even if the numbers are equal it will still return y.
		return y;
	}
}

//Finds maximum of two values
int max(int x, int y) {
	if (x > y){ //If x is the bigger number it will return x
		return x;
	}
	else { //Otherwise will return y; if x and y are equal it will still return y
		return y;
	}
}
